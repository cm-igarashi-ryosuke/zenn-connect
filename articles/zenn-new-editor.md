---
title: Zennのエディタとプレビューのリアルタイム反映・スクロール同期に対応しました
emoji: "🗒️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["zenn", "markdownit", "codemirror", "morphdom"]
published: false
publication_name: team_zenn
---

## はじめに
従来のZennのエディタは、プレビューを確認するためにエディタとプレビューを切り替える必要がありました。
![](https://storage.googleapis.com/zenn-user-upload-integration/a682595e15eb-20251204.gif)

今回対応した新しいエディタでは、切り替えなしに常にプレビューが表示され、ほぼリアルタイムでエディタの内容が反映されます。また、エディタのスクロール位置に合わせてプレビューのスクロール位置も同期されます。

![](https://storage.googleapis.com/zenn-user-upload-integration/f08dd686ffb8-20251204.gif)

実はこの機能、Zenn本体よりも先に、有志の方によりVSCode拡張の方に対応していただきました。

https://github.com/zenn-dev/zenn-vscode-extension/pull/115

この時の対応で、エディタのテキスト（Markdown）から変換されるHTMLのpタグなどに、テキストに対応する行番号の情報（以下のPRではソースマップと呼んでいます）を埋め込む対応も行われました。

https://github.com/zenn-dev/zenn-editor/pull/504

この行番号の情報はZennのエディタでも参照することができるので、理論上はZennのエディタでもスクロール同期の実装が可能！と思っていたのですが、ようやく対応することができました。

本記事では、プレビューのスクロール位置の同期について、技術的なトピックをいくつか紹介しようと思います。

## 前提知識

技術的な紹介をする前に、Zennのエディタがどのようにプレビュー（いま読んでいるこのページ）を生成しているかについて、基本的な部分をざっくりと説明します。

Zennのエディタで編集しているデータはMarkdown形式のテキストデータです。これを、[markdown-it](https://github.com/markdown-it/markdown-it) というライブラリを使い、Markdownの装飾を含むテキストデータをHTMLに変換します。

例えば、MarkdownのHeading2要素は、
```markdown
## Heading2
```
HTMLのh2タグに、
```html
<h2>Heading2</h2>
```
変換される、といった具合です。

Zenn独自の記法も、markdown-itに変換ルールを追加することでHTMLに変換されるようになっています。その他、KaTexなど一部はブラウザ上でHTMLに変換されたり、iframeで別途描画するものもあります。

## プレビューのリアルタイム反映

エディタの内容をほぼリアリタイムでプレビューに反映するには、

1. エディタの変更を監視
2. MarkdownからHTMLに変換
3. HTMLをプレビューに反映

というステップのループになります。

これを素朴に実装すると、HTMLをプレビューに反映したときに、HTML全体が更新されるため、プレビュー画面のチラツキが目立ってしまいます。またiframeなども更新のたびに読み込みが発生してしまいます。

素朴な実装:

```jsx
<div
  dangerouslySetInnerHTML={{ __html: bodyHtml }}
/>
```

画面のチラツキを防ぐために、HTMLの更新箇所を最小限にしたいです。そこで導入したのが [morphdom](https://github.com/patrick-steele-idem/morphdom) というライブラリです。

morphdomの使い方は非常にシンプルで、

```jsx
morphdom(beforeNode, afterNode);
```

第1引数に元のDOM Node、第2引数に変更後のDOM Nodeを指定することで、第1引数と第2引数の差分だけを、第1引数のDOM Nodeに反映します。Reactのような仮想DOMでも利用が可能です。

さらにオプションとしてライフサイクルフックが提供されているので、条件付きで更新させることも可能です。たとえはZennの場合、iframeのsrcのフラグメントにユニークなidが付与されるのですが、それが毎回ランダム文字列で更新されてしまうため、差分として更新され、再ロードされてしまいました。そこで、srcはチェックせずに中身のデータに変化があるかで判定するようにしています。

## プレビューのスクロール同期

スクロール位置の同期については、

1. エディタのスクロール位置の監視
2. 変化があったらエディタのスクロール位置を特定
3. プレビューのスクロール位置を移動

というステップのループになります。

エディタのスクロール位置については、Zennのエディタのベースとして使用しているライブラリ [codemirror](https://codemirror.net/) のインターフェイスを使って取得できます。詳細は割愛しますが、このとき、エディタの現在の行数だけでなく、次の行までの距離、つまり現在の行を0.0~1.0の精度で取得することで、より滑らかなスクロール同期が実現できます。

次に、プレビューのスクロール位置を移動します。プレビュー側のHTMLには、エディタの行数に対応する行番号の情報が含まれますが、すべての対応する行が存在するわけではありません。

例えばこの記事の冒頭のテキスト（わかりやすいように行番号を入れています）では、

```
1| ## はじめに
2| 従来のZennのエディタは、プレビューを確認するためにエディタとプレビューを切り替える必要がありました。
3| 
4| （イメージ）
5| 
6| 今回対応した新しいエディタでは、切り替えなしに常にプレビューが表示され、ほぼリアルタイムでエディタの内容が反映されます。また、エディタのスクロール位置に合わせてプレビューのスクロール位置も同期されます。
7| 
8| （イメージ）
```

以下のように変換されます。 `data-line` の値がエディタと対応する0始まりの行番号です。

```html
<h2 id="%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB" data-line="0" >はじめに</h2>
<p data-line="1" class="code-line">従来のZennのエディタは、プレビューを確認するためにエディタとプレビューを切り替える必要がありました。</p>
<p data-line="3" class="code-line">（イメージ）</p>
<p data-line="5" class="code-line">今回対応した新しいエディタでは、切り替えなしに常にプレビューが表示され、ほぼリアルタイムでエディタの内容が反映されます。また、エディタのスクロール位置に合わせてプレビューのスクロール位置も同期されます。</p>
<p data-line="7" class="code-line">（イメージ）</p>
```

なので、例えばエディタのスクロール位置が4.5の場合、4.5の上下の位置（この例では `data-line` が3と5）のDOMを探し、DOMの高さを計算して、4.5の位置に相当するところまでスクロールを移動させます。

他にもエッジケースは色々ありますが、基本的な考え方が分かっていれば対応できると思います。

## おわり

お読みいただきありがとうございました。Zennの新しいエディタの、プレビューのリアルタイム反映とスクロール同期の仕組みについて説明しました。何かの参考になれば幸いです。

また、エディタに関するフィードバックは[zenn-community](https://github.com/zenn-dev/zenn-community/issues)のissueでお寄せください。